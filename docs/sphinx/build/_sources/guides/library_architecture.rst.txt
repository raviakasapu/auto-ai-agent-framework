Library Architecture
====================

The Agent Framework is designed as a **reusable Python library** that can be imported
into any application requiring agentic AI capabilities.

Design Philosophy
-----------------

The framework follows a clear separation:

- **Generic Library** (``agent-framework-pypi/src/agent_framework/``) - Reusable, domain-agnostic components
- **Application Code** (e.g., ``bi_tools/``) - Domain-specific implementations

This allows the framework to be:

1. **Pip-installable** as a standalone package
2. **Extended** with domain-specific tools and services
3. **Reused** across multiple applications

Directory Structure
-------------------

.. code-block:: text

   project/
   ├── agent-framework-pypi/
   │   └── src/agent_framework/      # GENERIC LIBRARY (pip package)
   │       ├── __init__.py           # Public API exports
   │       ├── base.py               # BaseTool, BasePlanner, BaseMemory
   │       ├── core/
   │       │   ├── agent.py          # Agent class
   │       │   ├── manager_v2.py     # ManagerAgent class
   │       │   └── events.py         # EventBus
   │       ├── components/
   │       │   ├── planners.py       # ReAct, Router, Strategic planners
   │       │   ├── memory.py         # In-memory implementations
   │       │   └── message_store_memory.py  # Message store-backed memories
   │       ├── gateways/
   │       │   └── inference.py      # OpenAI, Google AI gateways
   │       ├── policies/             # Policy system & presets
   │       ├── services/             # Request context, context builder
   │       └── tools/utility/        # Generic tools
   │
   ├── bi_tools/                     # DOMAIN-SPECIFIC (example)
   │   ├── services/
   │   │   └── datamodel_service.py  # Power BI data model service
   │   └── tools/
   │       ├── column/               # Column tools
   │       ├── measure/              # Measure tools
   │       └── ...                   # Other domain tools
   │
   ├── configs/                      # YAML configurations & registries
   │
   └── deployment/                   # Factory and registry
       ├── factory.py                # Agent factory
       └── registry.py               # Component registry

Public API
----------

Import core components directly from the framework:

.. code-block:: python

   from agent_framework import (
       Agent,
       ManagerAgent,
       BaseTool,
       EventBus,
       get_preset,
       tool,              # NEW: Decorator for easy tool creation
       FunctionalTool,    # NEW: Functional tool base class
   )

   from agent_framework.base import Action, FinalResponse
   from agent_framework.gateways.inference import OpenAIGateway
   from agent_framework.components.planners import ReActPlanner

Creating Tools with the @tool Decorator
---------------------------------------

The easiest way to create a tool is using the ``@tool`` decorator:

.. code-block:: python

   from agent_framework import tool

   @tool
   def greet(name: str, formal: bool = False) -> str:
       '''Generate a greeting message.
       
       name: The name of the person to greet
       formal: Whether to use formal greeting
       '''
       if formal:
           return f"Good day, {name}."
       return f"Hello, {name}!"

   # The tool is now fully compatible with the agent framework
   result = greet.execute(name="Alice", formal=True)
   # Or call directly:
   result = greet(name="Bob")

**With custom configuration:**

.. code-block:: python

   from agent_framework import tool
   from pydantic import BaseModel, Field

   class CalculatorArgs(BaseModel):
       a: float = Field(..., description="First number")
       b: float = Field(..., description="Second number")
       operation: str = Field("add", description="Operation: add, sub, mul, div")

   @tool(name="calculator", description="Perform arithmetic operations", args_schema=CalculatorArgs)
   def calc(a: float, b: float, operation: str = "add") -> float:
       '''Calculator tool.'''
       ops = {"add": a + b, "sub": a - b, "mul": a * b, "div": a / b if b != 0 else 0}
       return ops.get(operation, a + b)

The ``@tool`` decorator automatically:

- Generates ``args_schema`` from function type hints
- Uses the docstring as the description
- Parses docstring for parameter descriptions
- Creates a ``BaseTool``-compatible instance

Creating Domain-Specific Tools (Class-Based)
--------------------------------------------

For more complex tools, create a class inheriting from ``BaseTool``:

.. code-block:: python

   # my_app/tools/my_tool.py
   from agent_framework import BaseTool
   from pydantic import BaseModel

   class MyToolArgs(BaseModel):
       query: str

   class MyToolOutput(BaseModel):
       result: str

   class MyTool(BaseTool):
       @property
       def name(self) -> str:
           return "my_tool"

       @property
       def description(self) -> str:
           return "Does something useful"

       @property
       def args_schema(self):
           return MyToolArgs

       @property
       def output_schema(self):
           return MyToolOutput

       def execute(self, **kwargs) -> dict:
           args = MyToolArgs(**kwargs)
           return {"result": f"Processed: {args.query}"}

2. **Register via YAML config** (``configs/tools/my_tool.yaml``):

.. code-block:: yaml

   name: MyTool
   class: my_app.tools.my_tool.MyTool

3. **Or register dynamically**:

.. code-block:: python

   from deployment.registry import register_tool
   from my_app.tools.my_tool import MyTool

   register_tool("MyTool", MyTool)

Pluggable Services
------------------

The framework uses pluggable services for domain-specific functionality.

**Registering a data model service:**

.. code-block:: python

   from agent_framework.services.context_builder import register_datamodel_service
   from bi_tools.services.datamodel_service import get_datamodel_service

   # Call this at application startup
   register_datamodel_service(get_datamodel_service)

**Registering additional config directories:**

.. code-block:: python

   from deployment.registry import register_config_root
   from pathlib import Path

   # Register your app's config directory
   register_config_root(Path("my_app/configs"))

Installation
------------

**For development (editable install):**

.. code-block:: bash

   pip install -e ./agent-framework-pypi

**For production:**

.. code-block:: bash

   pip install agentic-framework

Example: Building a New Application
-----------------------------------

.. code-block:: python

   # my_app/main.py
   from agent_framework import Agent, BaseTool, tool
   from agent_framework.gateways.inference import OpenAIGateway
   from agent_framework.components.planners import ReActPlanner
   from deployment.factory import AgentFactory

   # Option 1: Quick tool creation with decorator
   @tool
   def search_docs(query: str, limit: int = 10) -> list:
       '''Search documentation for relevant content.'''
       # Your implementation here
       return [{"title": "Result", "content": f"Found: {query}"}]

   # Option 2: Register class-based tools
   from deployment.registry import register_tool
   from my_app.tools import MyTool, AnotherTool

   register_tool("MyTool", MyTool)
   register_tool("AnotherTool", AnotherTool)

   # 2. Create agent from YAML config
   agent = AgentFactory.create_from_yaml("configs/agents/my_agent.yaml")

   # 3. Run the agent
   result = agent.run("Process this request")
   print(result)

Migration from Previous Versions
--------------------------------

**Import path changes:**

.. code-block:: python

   # Before
   from framework import Agent, BaseTool
   from framework.tools.column import AddColumnTool

   # After
   from agent_framework import Agent, BaseTool
   from bi_tools.tools.column import AddColumnTool

**YAML tool configs:**

Update the ``class`` path in your YAML configs:

.. code-block:: yaml

   # Before
   class: framework.tools.column.AddColumnTool

   # After
   class: bi_tools.tools.column.AddColumnTool

**New: Use @tool decorator for simple tools:**

.. code-block:: python

   # Before: 30+ lines of boilerplate
   class MyTool(BaseTool):
       @property
       def name(self): return "my_tool"
       # ... more boilerplate ...

   # After: Just a few lines
   from agent_framework import tool

   @tool
   def my_tool(arg: str) -> str:
       '''My tool description.'''
       return f"Result: {arg}"
