Flow Orchestration
==================

Flows describe higher-level orchestration that binds one or more agents to named
tasks. Store flow YAML anywhere in your repo (``flows/`` by convention) and load them
with ``FlowFactory``.

Example ``flows/schema_editor.yaml``::

   apiVersion: agent.framework/v1
   kind: Flow

   metadata:
     name: SchemaEditingFlow

   spec:
     agents:
       router:
         config: configs/agents/schema_editor_router.yaml
       research:
         config: configs/agents/research_assistant.yaml

     orchestrator: router

     steps:
       - name: list_tables
         agent: router
         task: "List the tables in the model"

       - name: add_relationship
         agent: router
         task_template: "Create a relationship between '{from_table}'[{from_column}] and '{to_table}'[{to_column}]"

Loading and running a flow::

   from agent_framework.flows.flow_factory import FlowFactory
   import asyncio

   flow = FlowFactory.create_from_yaml("flows/schema_editor.yaml")

   async def main():
       result = await flow.run("add_relationship", {
           "from_table": "Sales",
           "from_column": "CustomerId",
           "to_table": "Customers",
           "to_column": "Id",
       })
       print(result)

   asyncio.run(main())

Key concepts
------------

- **agents** – named references to agent configs. Each entry is instantiated via
  ``AgentFactory`` once when the flow is loaded.
- **orchestrator** – identifies the primary agent for a flow. It can be a
  manager agent or any other agent that coordinates work. Access via
  ``flow.orchestrator``.
- **steps** – declarative tasks that point at a specific agent. Each step can
  supply a fixed ``task`` string or a ``task_template`` with ``str.format``
  placeholders populated from runtime parameters.

Flows complement agent configs by defining how multiple agents are composed and
reused. They can be versioned, promoted, and inspected just like other YAML
artifacts in the ``configs/`` directory.

Reference architecture
----------------------

The logical execution looks like:

- **Flow orchestrator** (one of the instantiated agents) chooses which step to
  run. It is still a normal agent, with its own planner, memory, and tools, just
  declared in the flow as the ``orchestrator`` key.
- **Agent** (per step) → **Planner** → **Tool**. Each agent YAML in
  ``configs/agents/`` wires its planner, memory, and tool list; the planner
  creates ``Action`` objects that call tools from that agent's toolset. Memories
  are likewise private to the agent that owns them.
- **Tools** remain attached to the agent; the flow does not form a global tool
  bus. Swapping or extending tools happens by editing the agent YAML or the tool
  registry entry in ``configs/tools/``.
- **Workers/Delegation**: Manager agents can appear inside a flow just like any
  other agent. They delegate to their configured workers (also defined via agent
  YAML) and surface results back to the flow orchestrator.

When visualising the architecture, place planner/memory/tool nodes *inside* the
agent boxes rather than below the entire flow. That mirrors the runtime binding
implemented in ``AgentFactory`` and keeps flows focused on reusing full agents
instead of wiring individual tools.
