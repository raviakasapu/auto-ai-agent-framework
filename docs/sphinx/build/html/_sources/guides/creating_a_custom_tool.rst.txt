Creating a Custom Tool
======================

Define Schemas
--------------

Use Pydantic models to describe your tool inputs and outputs.

.. code-block:: python

   from pydantic import BaseModel

   class MyArgs(BaseModel):
       query: str

   class MyOut(BaseModel):
       result: str

Implement ``BaseTool``
----------------------

Subclass ``BaseTool`` and wire in the schemas.

.. code-block:: python

   from agent_framework import BaseTool

   class MyTool(BaseTool):
       @property
       def name(self):
           return "my_tool"

       @property
       def description(self):
           return "Does something useful"

       @property
       def args_schema(self):
           return MyArgs

       @property
       def output_schema(self):
           return MyOut

       def execute(self, **kwargs):
           data = MyArgs(**kwargs)
           return MyOut(result=f"Processed: {data.query}").model_dump()

Register & Reference
--------------------

Register the tool class (one-time) and reference it from YAML.

.. code-block:: python

   from deployment.registry import register_tool
   register_tool("MyTool", MyTool)

YAML snippet:

.. code-block:: yaml

   resources:
     tools:
       - name: my_tool
         type: MyTool
         config: {}
   spec:
     tools: [my_tool]

Zero-Boilerplate Option (Decorator)
-----------------------------------

Use the ``@tool`` decorator when you want a quick functional tool without writing a class.

.. code-block:: python

   from agent_framework import tool

   @tool(name="calculator", description="Add or subtract numbers")
   def calculator(operation: str, num1: float, num2: float) -> float:
       """operation: add|subtract|multiply|divide"""
       ops = {
           "add": num1 + num2,
           "subtract": num1 - num2,
           "multiply": num1 * num2,
           "divide": num1 / num2 if num2 else float("inf"),
       }
       return ops.get(operation, num1 + num2)

Decorated tools return a ``FunctionalTool`` instance that can be passed directly to agents in code:

.. code-block:: python

   agent = Agent(
       planner=planner,
       memory=memory,
       tools=[calculator],
       policies=get_preset("react_agent"),
   )

For YAML-driven configs, wrap the decorator in a small adapter class or register it via ``deployment.registry.register_tool`` before loading configs.
