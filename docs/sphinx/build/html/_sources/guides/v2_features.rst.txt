What's New in v2.x
==================

Version 2.x introduces major enhancements to the AI Agent Framework, focusing on
library packaging, developer ergonomics, and hierarchical orchestration.

v2.2 Highlights
---------------

- **Pip-installable library**: The generic framework now lives in ``agent_framework`` inside ``agent-framework-pypi``. Install with ``pip install agentic-framework`` or ``pip install -e ./agent-framework-pypi`` during development.
- **@tool decorator**: Author tools with regular Python functions using ``@agent_framework.tool``. Schemas are inferred from type hints, docstrings supply descriptions, and the decorator returns a ``FunctionalTool`` ready to pass to agents.
- **Policy presets**: Call ``get_preset(...)`` to configure completion, termination, loop prevention, human-in-the-loop, and checkpoint policies without wiring them manually.
- **Message store integrations**: ``MessageStoreMemory`` and ``HierarchicalMessageStoreMemory`` read from a custom ``BaseMessageStore``, enabling persisted conversation history and manager visibility.
- **Observability upgrades**: Phoenix/OpenTelemetry spans capture cost, usage, actor context, and prompt/tool bodies (controlled via env vars). ``progress_filters`` allow UI-specific streaming over WebSocket/HTTP.
- **Docs + manifest tooling**: ``agent_framework/utils/manifest_generator.py`` emits machine-readable tool specs, and ``docs_server`` can serve the manifest plus Sphinx reference in one FastAPI app.

v2.0 Enhancements
-----------------

These foundational changes introduced planner upgrades and manager orchestration that continue in v2.2.

New Planners
------------

ChatPlanner
~~~~~~~~~~~

Conversational AI planner for chat-style agents.

**Purpose**: Generate natural language responses using conversation history.

**Use Cases**:
- Q&A assistants
- Customer support bots
- General conversation agents

**Configuration**:

.. code-block:: yaml

   spec:
     planner:
       type: ChatPlanner
       config:
         inference_gateway: openai-chat
         system_prompt: "You are a helpful AI assistant."
         max_history_messages: 20

**Features**:
- Builds conversation history from memory
- Configurable system prompt for persona
- History window management
- Returns ``FinalResponse`` with generated text

**Example Agent**: ``configs/agents/chat_assistant.yaml``

ReActPlanner
~~~~~~~~~~~~

Iterative reasoning planner implementing the ReAct pattern (Reasoning + Acting).

**Purpose**: Multi-step problem solving with tools through iterative reasoning.

**Use Cases**:
- Complex data analysis
- Multi-step file operations
- Research and information gathering

**Configuration**:

.. code-block:: yaml

   spec:
     planner:
       type: ReActPlanner
       config:
         inference_gateway: openai-llm
         tool_descriptions:
           - name: read_file
             description: "Read contents of a file"
             args: [file_path]
           - name: write_file
             description: "Write content to a file"
             args: [file_path, content]
         max_iterations: 5

**Features**:
- Thought → Action → Observation loop
- Iterative tool execution
- Max iteration safety limit
- JSON-based decision parsing

**Flow**:

1. **Thought**: LLM reasons about the task
2. **Action**: Selects a tool and arguments
3. **Observation**: Receives tool result
4. **Repeat**: Until task complete or max iterations

WorkerRouterPlanner
~~~~~~~~~~~~~~~~~~~

Orchestrator-level planner for intent classification and worker delegation.

**Purpose**: Route user requests to specialized worker agents based on intent.

**Use Cases**:
- Multi-domain systems
- Orchestrator agents
- Intent-based routing

**Configuration**:

.. code-block:: yaml

   spec:
     planner:
       type: WorkerRouterPlanner
       config:
         inference_gateway: openai-llm
         worker_keys: [chat, tools, research]
         rules:
           - worker: tools
             include: ["file", "data", "execute"]
           - worker: research
             include: ["search", "find", "lookup"]
         default_worker: chat
         log_details: true

**Features**:
- Heuristic rule-based routing (fast)
- LLM-based classification (flexible)
- Default worker fallback
- Graceful error handling

**Routing Strategy**:

1. Apply heuristic rules first (keyword matching)
2. If no match, ask LLM to classify intent
3. If LLM fails, use default worker
4. If no default, return helpful error message

Enhanced ManagerAgent
---------------------

The ``ManagerAgent`` has been significantly enhanced to support planner-driven delegation.

**Previous Behavior** (v1.x):
- Always delegated to first worker
- No intent classification
- Limited flexibility

**New Behavior** (v2.0):
- Uses planner to select worker
- Supports named workers
- Can return ``FinalResponse`` directly
- Enhanced event tracking

**Configuration**:

.. code-block:: yaml

   apiVersion: agent.framework/v1
   kind: ManagerAgent

   spec:
     planner:
       type: WorkerRouterPlanner
       config:
         worker_keys: [worker1, worker2]
     
     workers:
       - name: worker1
         agent_config_path: configs/agents/worker1.yaml
       - name: worker2
         agent_config_path: configs/agents/worker2.yaml

**New Events**:
- ``delegation_planned``: Planner chose a worker
- ``delegation_executed``: Worker completed task

Named Workers
~~~~~~~~~~~~~

Workers are now identified by name instead of index:

.. code-block:: python

   # Workers stored as dict[str, Agent]
   manager.workers = {
       "chat": chat_agent,
       "tools": tool_agent,
       "research": research_agent
   }

**Benefits**:
- More readable configurations
- Explicit worker references
- Better error messages
- Easier debugging

Architecture Changes
--------------------

Hierarchical Orchestration
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Build multi-level agent teams:

.. code-block:: text

   Director (ManagerAgent)
     ├─ Manager A (ManagerAgent)
     │   ├─ Worker A1 (Agent + ChatPlanner)
     │   └─ Worker A2 (Agent + LLMRouterPlanner)
     └─ Manager B (ManagerAgent)
         ├─ Worker B1 (Agent + ReActPlanner)
         └─ Worker B2 (Agent + tools)

**Example**: A Director manages PBI and Database teams, each with specialized workers.

Planner Ecosystem
~~~~~~~~~~~~~~~~~

Choose the right "brain" for each agent:

+----------------------+---------------------------+------------------------+
| Planner              | Use Case                  | Returns                |
+======================+===========================+========================+
| StaticPlanner        | Rule-based routing        | Action or Final        |
+----------------------+---------------------------+------------------------+
| ChatPlanner          | Conversational AI         | FinalResponse          |
+----------------------+---------------------------+------------------------+
| LLMRouterPlanner     | Tool selection            | Action (tool)          |
+----------------------+---------------------------+------------------------+
| ReActPlanner         | Iterative reasoning       | Action or Final        |
+----------------------+---------------------------+------------------------+
| WorkerRouterPlanner  | Intent classification     | Action (worker)        |
+----------------------+---------------------------+------------------------+

Migration Guide
---------------

From v1.x to v2.0
~~~~~~~~~~~~~~~~~

**1. Update Manager Configs**

Add ``name`` field to each worker:

.. code-block:: yaml

   # Before (v1.x)
   workers:
     - agent_config_path: worker1.yaml
     - agent_config_path: worker2.yaml

   # After (v2.0)
   workers:
     - name: worker1
       agent_config_path: worker1.yaml
     - name: worker2
       agent_config_path: worker2.yaml

**2. Update Planner**

Change to ``WorkerRouterPlanner`` for orchestrators:

.. code-block:: yaml

   spec:
     planner:
       type: WorkerRouterPlanner
       config:
         worker_keys: [worker1, worker2]
         rules: [...]

**3. Test Delegation**

Verify intent classification works:

.. code-block:: python

   orchestrator = AgentFactory.create_from_yaml("orchestrator.yaml")
   result = await orchestrator.run("Your test task")

**4. Enable Logging**

For debugging:

.. code-block:: bash

   export AGENT_LOG_LEVEL=DEBUG
   export AGENT_LOG_ROUTER_DETAILS=true

Breaking Changes
~~~~~~~~~~~~~~~~

- **ManagerAgent**: No longer delegates to first worker by default
- **Workers**: Must be named in YAML (or will get auto-generated names)
- **Planner Required**: Managers must have a planner that returns ``Action(tool_name=<worker_key>)``

New Examples
------------

Chat Assistant
~~~~~~~~~~~~~~

Simple conversational agent:

.. code-block:: bash

   python -c "
   from deployment.factory import AgentFactory
   import asyncio

   async def main():
       agent = AgentFactory.create_from_yaml('configs/agents/chat_assistant.yaml')
       result = await agent.run('Hello! Tell me about AI agents.')
       print(result)

   asyncio.run(main())
   "

Orchestrator
~~~~~~~~~~~~

Multi-worker system:

.. code-block:: bash

   python -c "
   from deployment.factory import AgentFactory
   import asyncio

   async def main():
       orch = AgentFactory.create_from_yaml('configs/agents/orchestrator.yaml')
       
       # Routes to chat worker
       r1 = await orch.run('Hello!')
       
       # Routes to tool worker
       r2 = await orch.run('List all tables')
       
       print(f'Chat: {r1}')
       print(f'Tool: {r2}')

   asyncio.run(main())
   "

Best Practices
--------------

Planner Selection
~~~~~~~~~~~~~~~~~

- **ChatPlanner**: For conversational agents without tools
- **LLMRouterPlanner**: For single agents with multiple tools
- **ReActPlanner**: For complex multi-step tasks
- **WorkerRouterPlanner**: For orchestrators managing workers
- **StaticPlanner**: For simple keyword-based routing

Worker Design
~~~~~~~~~~~~~

- Keep workers focused on single domains
- Use descriptive worker names
- Provide clear tool descriptions
- Test workers independently

Orchestration
~~~~~~~~~~~~~

- Start with 2-3 workers, expand as needed
- Use rules for common patterns (fast)
- Fall back to LLM for edge cases (flexible)
- Always provide a default worker

Memory Management
~~~~~~~~~~~~~~~~~

- Set appropriate ``max_history_messages``
- Clear memory for new conversations
- Persist agent instances for chat continuity

See Also
--------

- :doc:`concepts` - Core framework concepts
- :doc:`creating_a_custom_tool` - Tool development
- :doc:`defining_agents_with_yaml` - Agent configuration
- :doc:`../api/index` - Complete API reference
